# .github/workflows/projects-autoadd.yml
# ELIS — Projects Auto-Add
#
# Purpose
#   • When an Issue/PR is OPENED, REOPENED, or LABELLED with `ELIS-Validation` or `ci`,
#     automatically add it to the ELIS Project (v2) and set a sensible Status.
#       - Pull requests → Status = "In review"
#       - Issues        → Status = "To do"
#
# Requirements
#   1) Repository variable:  PROJECT_ID  → your Project (v2) ID (e.g., PVT_xxx…)
#      Settings → Secrets and variables → Actions → Variables → New → PROJECT_ID
#   2) (Recommended) Repo secret:  PROJECTS_TOKEN  → classic PAT with scopes: repo, project
#      Needed for user-owned Projects v2 to avoid “Resource not accessible by integration”.
#      If not set, we fall back to GITHUB_TOKEN (may be insufficient on user-owned Projects).
#
# Notes
#   • Safe to re-run: all mutations are idempotent.
#   • Uses `gh` (GitHub CLI) + GraphQL and `jq` for JSON extraction.

name: ELIS - Projects Auto-Add

on:
  issues:
    types: [opened, reopened, labeled]
  pull_request:
    types: [opened, reopened, labeled]

permissions:
  contents: read
  issues: write
  pull-requests: write
  repository-projects: write  # required to write to Projects via GraphQL

jobs:
  add_and_set_status:
    runs-on: ubuntu-latest
    env:
      PROJECT_ID: ${{ vars.PROJECT_ID }}
      # Prefer the PAT if provided; otherwise fall back to GITHUB_TOKEN
      GH_TOKEN: ${{ secrets.PROJECTS_TOKEN != '' && secrets.PROJECTS_TOKEN || secrets.GITHUB_TOKEN }}

    steps:
      - name: Tooling check
        run: |
          gh --version
          jq --version

      - name: Resolve content type and node id
        id: ids
        run: |
          if [ "${{ github.event_name }}" = "issues" ]; then
            echo "TYPE=issue" >> $GITHUB_OUTPUT
            echo "NUM=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
            CID=$(gh api repos/${{ github.repository }}/issues/${{ github.event.issue.number }} --jq .node_id)
          else
            echo "TYPE=pr" >> $GITHUB_OUTPUT
            echo "NUM=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            CID=$(gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }} --jq .node_id)
          fi
          echo "CID=$CID" >> $GITHUB_OUTPUT
          echo "Content node id: $CID"

      - name: Read labels and (if matching) ensure item is on the Project
        id: add
        run: |
          CID="${{ steps.ids.outputs.CID }}"

          # Collect labels (Issues and PRs are Labelable)
          LABS=$(gh api graphql -f query='
            query($id:ID!){
              node(id:$id){
                ... on Labelable{ labels(first:100){ nodes{ name } } }
              }
            }' -f id="$CID" --jq '.data.node.labels.nodes[].name' | tr '\n' ' ' | tr -s ' ')
          echo "Labels: $LABS"

          case " $LABS " in
            *" ELIS-Validation "*|*" ci "*)
              echo "→ Matching label found; ensuring Project membership…"
              # Idempotent: re-adding is fine; ignore error if already present
              gh api graphql -f query='mutation($pid:ID!,$cid:ID!){
                addProjectV2ItemById(input:{projectId:$pid,contentId:$cid}){ item { id } }
              }' -f pid="$PROJECT_ID" -f cid="$CID" >/dev/null 2>&1 || true
              echo "ADDED=1" >> $GITHUB_OUTPUT
            ;;
            *)
              echo "→ No matching labels; skipping add for now."
              echo "ADDED=0" >> $GITHUB_OUTPUT
            ;;
          esac

      - name: Resolve Project item id (robust, union-safe)
        id: item
        run: |
          CID="${{ steps.ids.outputs.CID }}"

          # Helper to fetch ITEM_ID (try twice to avoid race conditions)
          find_item () {
            gh api graphql -f query='
              query($pid:ID!){
                node(id:$pid){
                  ... on ProjectV2{
                    items(first:200){
                      nodes{
                        id
                        content{
                          __typename
                          ... on Issue{ id }
                          ... on PullRequest{ id }
                        }
                      }
                    }
                  }
                }
              }' -f pid="$PROJECT_ID" \
            | jq -r --arg CID "$CID" '.data.node.items.nodes[] | select(.content.id==$CID) | .id' | head -n1
          }

          ITEM_ID="$(find_item)"
          if [ -z "$ITEM_ID" ]; then
            echo "Item not found yet; waiting briefly and retrying…"
            sleep 5
            ITEM_ID="$(find_item)"
          fi

          echo "ITEM_ID=$ITEM_ID" >> $GITHUB_OUTPUT
          echo "ITEM_ID=$ITEM_ID"

      - name: Cache Status field + option ids (union-safe)
        id: statusmeta
        run: |
          META=$(gh api graphql -f query='
            query($pid:ID!){
              node(id:$pid){
                ... on ProjectV2{
                  fields(first:50){
                    nodes{
                      __typename
                      # IMPORTANT: You cannot select fields on the union directly.
                      # Narrow to the concrete single-select type first:
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        options { id name }
                      }
                    }
                  }
                }
              }
            }' -f pid="$PROJECT_ID")

          STATUS_FIELD_ID=$(echo "$META" | jq -r '.data.node.fields.nodes[] | select(.name=="Status") | .id')
          INREVIEW_ID=$(echo "$META"       | jq -r '.data.node.fields.nodes[] | select(.name=="Status") | .options[] | select(.name=="In review") | .id')
          TODO_ID=$(echo "$META"           | jq -r '.data.node.fields.nodes[] | select(.name=="Status") | .options[] | select(.name=="To do") | .id')

          if [ -z "$STATUS_FIELD_ID" ] || [ -z "$INREVIEW_ID" ] || [ -z "$TODO_ID" ]; then
            echo "Failed to resolve Status field/options. Is this a Project (v2) with a Status field?"
            exit 1
          fi

          echo "STATUS_FIELD_ID=$STATUS_FIELD_ID" >> $GITHUB_OUTPUT
          echo "INREVIEW_ID=$INREVIEW_ID"         >> $GITHUB_OUTPUT
          echo "TODO_ID=$TODO_ID"                 >> $GITHUB_OUTPUT

      # ─────────────────────────────────────────────────────────────────────
      # PR opened/reopened → set Status = In review (only if labelled)
      - name: PR opened/reopened → In review
        if: steps.ids.outputs.TYPE == 'pr' && (github.event.action == 'opened' || github.event.action == 'reopened')
        run: |
          if [ -z "${{ steps.item.outputs.ITEM_ID }}" ]; then
            echo "No Project item resolved yet; skipping."
            exit 0
          fi

          # Confirm label policy before setting Status
          CID="${{ steps.ids.outputs.CID }}"
          LABS=$(gh api graphql -f query='
            query($id:ID!){
              node(id:$id){
                ... on Labelable{ labels(first:100){ nodes{ name } } }
              }
            }' -f id="$CID" --jq '.data.node.labels.nodes[].name' | tr '\n' ' ' | tr -s ' ')
          case " $LABS " in *" ELIS-Validation "*|*" ci "*);; *) echo "PR not labelled for auto-set; skipping."; exit 0;; esac

          gh api graphql -f query='mutation($pid:ID!,$iid:ID!,$fid:ID!,$oid:ID!){
            updateProjectV2ItemFieldValue(input:{
              projectId:$pid,itemId:$iid,fieldId:$fid,
              value:{singleSelectOptionId:$oid}
            }){ projectV2Item{ id } }
          }' \
          -f pid="$PROJECT_ID" \
          -f iid="${{ steps.item.outputs.ITEM_ID }}" \
          -f fid="${{ steps.statusmeta.outputs.STATUS_FIELD_ID }}" \
          -f oid="${{ steps.statusmeta.outputs.INREVIEW_ID }}"

      # PR is labelled later with a matching label → set Status = In review
      - name: PR labelled → In review
        if: steps.ids.outputs.TYPE == 'pr' && github.event.action == 'labeled' && (github.event.label.name == 'ci' || github.event.label.name == 'ELIS-Validation')
        run: |
          if [ -z "${{ steps.item.outputs.ITEM_ID }}" ]; then
            echo "No Project item resolved yet; skipping."
            exit 0
          fi
          gh api graphql -f query='mutation($pid:ID!,$iid:ID!,$fid:ID!,$oid:ID!){
            updateProjectV2ItemFieldValue(input:{
              projectId:$pid,itemId:$iid,fieldId:$fid,
              value:{singleSelectOptionId:$oid}
            }){ projectV2Item{ id } }
          }' \
          -f pid="$PROJECT_ID" \
          -f iid="${{ steps.item.outputs.ITEM_ID }}" \
          -f fid="${{ steps.statusmeta.outputs.STATUS_FIELD_ID }}" \
          -f oid="${{ steps.statusmeta.outputs.INREVIEW_ID }}"

      # Issue opened/reopened (and carries a matching label) → set Status = To do
      - name: Issue opened/reopened → To do
        if: steps.ids.outputs.TYPE == 'issue' && (github.event.action == 'opened' || github.event.action == 'reopened')
        run: |
          if [ -z "${{ steps.item.outputs.ITEM_ID }}" ]; then
            echo "No Project item resolved yet; skipping."
            exit 0
          fi

          CID="${{ steps.ids.outputs.CID }}"
          LABS=$(gh api graphql -f query='
            query($id:ID!){
              node(id:$id){
                ... on Labelable{ labels(first:100){ nodes{ name } } }
              }
            }' -f id="$CID" --jq '.data.node.labels.nodes[].name' | tr '\n' ' ' | tr -s ' ')
          case " $LABS " in *" ELIS-Validation "*|*" ci "*);; *) echo "Issue not labelled for auto-set; skipping."; exit 0;; esac

          gh api graphql -f query='mutation($pid:ID!,$iid:ID!,$fid:ID!,$oid:ID!){
            updateProjectV2ItemFieldValue(input:{
              projectId:$pid,itemId:$iid,fieldId:$fid,
              value:{singleSelectOptionId:$oid}
            }){ projectV2Item{ id } }
          }' \
          -f pid="$PROJECT_ID" \
          -f iid="${{ steps.item.outputs.ITEM_ID }}" \
          -f fid="${{ steps.statusmeta.outputs.STATUS_FIELD_ID }}" \
          -f oid="${{ steps.statusmeta.outputs.TODO_ID }}"
