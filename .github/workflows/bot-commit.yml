# ELIS - Bot Commit and PR (auto-merge, no-PAT)
# One-step workflow: reads content_raw, creates branch, commits file, opens PR, enables auto-merge.

name: ELIS - Bot Commit and PR (auto-merge, no-PAT)

on:
  workflow_dispatch:
    inputs:
      file_path:
        description: "Path to create/update (e.g., scripts/hello_bot.py)"
        required: true
      content_raw:
        description: "Raw file content (paste full code here)"
        required: true
      commit_message:
        description: "Concise commit message"
        required: true
      target_branch:
        description: "Base branch (blank = repo default)"
        required: false
        default: ""
      pr_title:
        description: "Pull Request title"
        required: false
        default: "Automated update"
      pr_body:
        description: "Pull Request body"
        required: false
        default: "Automated update by ELIS Bot."

jobs:
  commit-and-pr:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Commit, PR and auto-merge (github-script)
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            // Inputs injected as JSON-safe strings
            const inPath  = ( ${{ toJson(inputs.file_path) }}      || "" ).trim();
            const inRaw   =   ${{ toJson(inputs.content_raw) }};           // keep newlines verbatim
            const inMsg   = ( ${{ toJson(inputs.commit_message) }} || "" ).trim();
            const inBase  = ( ${{ toJson(inputs.target_branch) }}  || "" ).trim();
            const prTitle = ( ${{ toJson(inputs.pr_title) }}       || "Automated update" ).trim();
            const prBody  = ( ${{ toJson(inputs.pr_body) }}        || "Automated update by ELIS Bot." ).trim();

            if (!inPath) core.setFailed("file_path is empty");
            if (!inRaw)  core.setFailed("content_raw is empty");
            if (!inMsg)  core.setFailed("commit_message is empty");

            // Sanitize path
            const filePath = inPath.replace(/^file_path:\s*/i, "").replace(/\/+/g, "/").replace(/^\/|\/$/g, "");
            const { owner, repo } = context.repo;

            // Resolve base branch (repo default if blank)
            let baseBranch = inBase;
            if (!baseBranch) {
              const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
              baseBranch = repoInfo.default_branch || "main";
            }
            core.info(`Using base branch: ${baseBranch}`);

            // Get base SHA
            const { data: ref } = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
            const baseSha = ref.object.sha;

            // Create bot branch
            const ts = new Date().toISOString().replace(/[-:TZ.]/g, "").slice(0,14);
            const safe = (inMsg.replace(/[^a-zA-Z0-9-_ ]/g,"").replace(/\s+/g,"-") || "update");
            const newBranch = `bot/${safe}-${ts}`;
            await github.rest.git.createRef({ owner, repo, ref: `refs/heads/${newBranch}`, sha: baseSha });

            // Check if file exists on new branch (to supply sha on update)
            let currentSha;
            try {
              const { data: existing } = await github.rest.repos.getContent({ owner, repo, path: filePath, ref: newBranch });
              if (!Array.isArray(existing)) currentSha = existing.sha;
            } catch (e) {
              if (e.status !== 404) throw e; // ignore not found
            }

            // Create or update file (content_raw encoded to base64 internally)
            await github.rest.repos.createOrUpdateFileContents({
              owner, repo, path: filePath, branch: newBranch,
              message: inMsg,
              content: Buffer.from(inRaw, "utf8").toString("base64"),
              sha: currentSha,
              committer: { name: "ELIS Bot", email: "233278419+elis-bot@users.noreply.github.com" },
              author:    { name: "ELIS Bot", email: "233278419+elis-bot@users.noreply.github.com" }
            });

            // Open PR
            const { data: pr } = await github.rest.pulls.create({
              owner, repo, title: prTitle, body: prBody, head: newBranch, base: baseBranch
            });
            core.info(`PR #${pr.number} â†’ ${pr.html_url}`);

            // Enable auto-merge (squash)
            try {
              await github.graphql(
                `mutation($prId: ID!) {
                  enablePullRequestAutoMerge(input:{ pullRequestId: $prId, mergeMethod: SQUASH }) { clientMutationId }
                }`,
                { prId: pr.node_id }
              );
              core.info("Auto-merge enabled (SQUASH).");
            } catch (e) {
              core.warning(`Auto-merge not enabled (check repo setting): ${e.message}`);
            }
