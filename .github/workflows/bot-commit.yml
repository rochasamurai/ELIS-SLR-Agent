# ELIS - Bot Commit (direct to elis-bot via GitHub App)
# -----------------------------------------------------------------------------
# Purpose:
#   Create or update a single file on a working branch, commit it, push it,
#   and optionally open/refresh a PR to main — using RAW TEXT ONLY.
#
# Why this version:
#   - GitHub workflow_dispatch inputs don’t preserve real newlines; authors paste
#     text where "\n" appears literally. This workflow converts those sequences
#     back into real newlines and writes the file with LF endings.
#   - No Base64 needed; simpler for PM users.
#
# Key behaviours:
#   • Newline-safe: turns literal "\n" into real newlines; normalises CRLF → LF.
#   • Idempotent: if the file content is unchanged, no commit is created.
#   • Branch hygiene: re-creates work branch from base on every run to avoid NFF.
#   • Guarded PR: opened only when there’s a real diff vs base.
# -----------------------------------------------------------------------------

name: ELIS - Bot Commit (direct to elis-bot via GitHub App)

on:
  workflow_dispatch:
    inputs:
      file_path:
        description: "Path (relative to repo root) of the file to create/update"
        required: true
      content_raw:
        description: "File content as RAW TEXT (literal \\n will become real newlines)"
        required: true
      commit_message:
        description: "Commit message (Conventional Commits style)"
        required: true
      base_branch:
        description: "Base branch name"
        required: false
        default: "main"
      work_branch:
        description: "Working branch name"
        required: false
        default: "elis-bot"
      open_pr:
        description: "Whether to open a pull request to the base branch (true|false)"
        required: false
        default: "true"

permissions:
  contents: write
  pull-requests: write

concurrency:
  # Prevent concurrent runs on the same work branch from racing.
  group: bot-commit-${{ github.event.inputs.work_branch }}
  cancel-in-progress: false

jobs:
  commit-file:
    runs-on: ubuntu-latest
    env:
      FILE_PATH: ${{ github.event.inputs.file_path }}
      CONTENT_RAW: ${{ github.event.inputs.content_raw }}
      COMMIT_MSG: ${{ github.event.inputs.commit_message }}
      BASE_BRANCH: ${{ github.event.inputs.base_branch }}
      WORK_BRANCH: ${{ github.event.inputs.work_branch }}
      OPEN_PR: ${{ github.event.inputs.open_pr }}

    steps:
      # 1) Checkout base with full history (we will rebuild work branch cleanly)
      - name: Checkout base
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      # 2) Prepare/clean working branch from base (avoid non-fast-forward)
      - name: Reset work branch from base
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin "${BASE_BRANCH}" --depth=1
          # Create or reset WORK_BRANCH to BASE_BRANCH
          if git show-ref --quiet "refs/heads/${WORK_BRANCH}"; then
            git checkout "${WORK_BRANCH}"
            git reset --hard "origin/${BASE_BRANCH}"
          else
            git checkout -b "${WORK_BRANCH}" "origin/${BASE_BRANCH}"
          fi

      # 3) Write content: convert literal "\n" to newline, normalise CRLF to LF
      - name: Write file content from RAW TEXT
        shell: bash
        run: |
          set -euo pipefail
          python - << 'PY'
          import os, pathlib, sys
          root = pathlib.Path(os.environ["GITHUB_WORKSPACE"])
          target = root / os.environ["FILE_PATH"]
          raw = os.environ["CONTENT_RAW"]

          # Convert literal sequences to real characters:
          # - turn '\\r\\n' and '\\n' into '\n'
          # - normalise any stray '\r' to '\n'
          text = raw.replace("\\r\\n", "\n").replace("\\n", "\n")
          text = text.replace("\r\n", "\n").replace("\r", "\n")

          target.parent.mkdir(parents=True, exist_ok=True)
          with open(target, "w", encoding="utf-8", newline="\n") as f:
            f.write(text)

          # Ensure trailing newline (POSIX convention; helps diffs)
          with open(target, "rb+") as f:
            f.seek(0, 2)
            if f.tell() == 0:
              f.write(b"\n")
            else:
              f.seek(-1, 2)
              if f.read(1) != b"\n":
                f.write(b"\n")

          print(f"Wrote {target} ({target.stat().st_size} bytes)")
          PY

      # 4) Commit only if content changed
      - name: Commit changes (if any)
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -- "${FILE_PATH}"

          if git diff --cached --quiet -- "${FILE_PATH}"; then
            echo "No changes detected for ${FILE_PATH}; skipping commit."
            echo "changed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          git commit -m "${COMMIT_MSG}"
          git push origin "HEAD:${WORK_BRANCH}"
          echo "changed=true" >> $GITHUB_OUTPUT

      # 5) Open or refresh PR only when there are commits (skip on no-op)
      - name: Open/refresh PR to base
        if: ${{ env.OPEN_PR == 'true' }}
        uses: actions/github-script@v6
        with:
          script: |
            const core = require('@actions/core');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const base = process.env.BASE_BRANCH;
            const head = process.env.WORK_BRANCH;

            // Check for existing open PR from head->base
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: 'open', base, head: `${owner}:${head}`
            });

            if (prs.length === 0) {
              // Verify there are commits between branches; if none, skip PR creation
              const cmp = await github.rest.repos.compareCommits({
                owner, repo, base, head
              });
              if (cmp.data.status === 'ahead' && cmp.data.ahead_by > 0) {
                await github.rest.pulls.create({
                  owner, repo, base, head,
                  title: process.env.COMMIT_MSG,
                  body: 'Automated bot commit (raw text, newline-safe).'
                });
              } else {
                core.info('No commits between base and work branches; PR not created.');
              }
            } else {
              core.info('PR already exists — no action needed.');
            }
