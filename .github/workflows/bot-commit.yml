# ELIS - Bot Commit and PR (auto-merge, no-PAT)
# Purpose: allow the PM to paste raw code (text) and get a branch, PR, and auto-merge into main.
# Security: uses GitHub's built-in GITHUB_TOKEN (least privilege to this repo). No PAT needed.

name: ELIS - Bot Commit and PR (auto-merge, no-PAT)

on:
  workflow_dispatch:
    inputs:
      file_path:
        description: "Path to create/update (e.g., scripts/validate_json.py)"
        required: true
      content_raw:
        description: "Raw file content (recommended). Leave empty if using base64."
        required: false
      content_base64:
        description: "Base64 file content (optional fallback for binaries/edge cases)."
        required: false
      commit_message:
        description: "Concise commit message (e.g., chore: add validator)"
        required: true
      target_branch:
        description: "Base branch to branch off"
        required: false
        default: "main"
      pr_title:
        description: "Pull Request title"
        required: false
        default: "Automated update"
      pr_body:
        description: "Pull Request body"
        required: false
        default: "Automated update by ELIS Bot."

jobs:
  commit-and-pr:
    runs-on: ubuntu-latest

    # Grant only what is needed to push commits and open PRs.
    permissions:
      contents: write
      pull-requests: write

    env:
      # Built-in token scoped to this repository run. Safer than PAT for this use case.
      GH_TOKEN: ${{ github.token }}
      # Use the bot identity (noreply) to avoid exposing real e-mail addresses.
      GIT_AUTHOR_NAME: ELIS Bot
      GIT_AUTHOR_EMAIL: 233278419+elis-bot@users.noreply.github.com
      GIT_COMMITTER_NAME: ELIS Bot
      GIT_COMMITTER_EMAIL: 233278419+elis-bot@users.noreply.github.com

    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          # Always start from the selected base branch.
          ref: ${{ inputs.target_branch }}

      - name: Prepare working branch name
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          # Build a deterministic, safe branch name from the commit message and a UTC timestamp.
          ts="$(date -u +'%Y%m%d-%H%M%S')"
          safe_msg="$(echo "${{ inputs.commit_message }}" | tr ' ' '-' | tr -cd '[:alnum:]-_')"
          echo "branch=bot/${safe_msg:-update}-${ts}" >> "$GITHUB_OUTPUT"

      - name: Create working branch
        shell: bash
        run: git switch -c "${{ steps.prep.outputs.branch }}"

      - name: Write file content (prefers raw; falls back to base64)
        shell: bash
        env:
          FILE_PATH: ${{ inputs.file_path }}
          CONTENT_RAW: ${{ inputs.content_raw }}
          CONTENT_B64: ${{ inputs.content_base64 }}
        run: |
          set -euo pipefail

          # Sanitize accidental prefixes and path mishaps from UI input.
          # - strip accidental "file_path:" prefixes
          # - trim trailing spaces
          # - collapse multiple slashes
          fp="$(printf '%s' "$FILE_PATH" | sed -E 's/^file_path:[[:space:]]*//; s#[[:space:]]+$##; s#//+#/#g')"
          mkdir -p "$(dirname "$fp")"

          # Use Python to reliably handle UTF-8, ensure trailing LF, and decode base64 when needed.
          python - << 'PY'
import os, sys, base64, binascii

fp  = os.environ["FILE_PATH"]
raw = os.environ.get("CONTENT_RAW") or ""
b64 = os.environ.get("CONTENT_B64") or ""

def write_text(txt: str) -> None:
    # Write with LF endings and ensure a trailing newline for POSIX tools.
    with open(fp, "w", encoding="utf-8", newline="\n") as f:
        f.write(txt)
    with open(fp, "rb+") as f:
        f.seek(0, 2)
        if f.tell() > 0:
            f.seek(-1, 2)
            if f.read(1) != b"\n":
                f.write(b"\n")

if raw.strip():
    # Preferred path: plain text is simpler and less error-prone than base64.
    write_text(raw)
elif b64.strip():
    # Fallback: accept strict base64 first; if it fails, try a tolerant decode.
    try:
        data = base64.b64decode(b64, validate=True)
    except (binascii.Error, ValueError):
        data = base64.b64decode(b64)
    write_text(data.decode("utf-8", errors="replace"))
else:
    print("ERROR: Provide content_raw or content_base64.", file=sys.stderr)
    sys.exit(1)
PY

          # Guard against empty/failed writes.
          test -s "$fp" || { echo "Decoded file is empty"; exit 1; }
          git status --porcelain

      - name: Commit changes
        shell: bash
        run: |
          # Stage and commit using the bot identity configured in env.
          git add -A
          git -c user.name="$GIT_AUTHOR_NAME" -c user.email="$GIT_AUTHOR_EMAIL" \
              commit -m "${{ inputs.commit_message }}"

      - name: Push branch
        shell: bash
        run: git push --set-upstream origin "${{ steps.prep.outputs.branch }}"

      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          # Open a PR from the bot branch to the chosen base branch.
          gh pr create \
            --title "${{ inputs.pr_title }}" \
            --body  "${{ inputs.pr_body }}" \
            --base  "${{ inputs.target_branch }}" \
            --head  "${{ steps.prep.outputs.branch }}"

      - name: Enable auto-merge (squash)
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          # Turn on auto-merge; GitHub will merge once checks (if any) pass.
          pr_url="$(gh pr view --json url -q .url)"
          gh pr merge "$pr_url" --squash --auto
          echo "Auto-merge enabled for: $pr_url"
