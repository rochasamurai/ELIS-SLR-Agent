# ELIS - Bot Commit (direct to elis-bot via GitHub App)
# Paste raw code -> commit directly to the persistent integration branch "elis-bot".
# Uses a short-lived installation token minted from your GitHub App (repo-scoped, safer than PAT).

name: ELIS - Bot Commit (direct to elis-bot via GitHub App)

on:
  workflow_dispatch:
    inputs:
      file_path:
        description: "Path to create/update (e.g., scripts/validate_json.py)"
        required: true
      content_raw:
        description: "Raw file content (paste the full code here)"
        required: true
      commit_message:
        description: "Concise commit message (e.g., feat: add validator)"
        required: true
      base_branch:
        description: "Base branch to initialise elis-bot from (blank = repository default)"
        required: false
        default: ""

jobs:
  commit-direct:
    runs-on: ubuntu-latest

    # We only need read here; writes are performed via the App installation token.
    permissions:
      contents: read

    steps:
      # 1) Mint a repo-scoped installation token from the GitHub App
      - name: Mint installation token (GitHub App)
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.ELIS_APP_ID }}
          private-key: ${{ secrets.ELIS_APP_PRIVATE_KEY }}
          installation-id: ${{ secrets.ELIS_INSTALLATION_ID }}

      # 2) Commit the provided file directly to the "elis-bot" branch
      - name: Commit directly to elis-bot (github-script)
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // ---- Read inputs (kept JSON-safe by toJson) ---------------------
            const inPath  = ( ${{ toJson(inputs.file_path) }}      || "" ).trim();
            const inRaw   =   ${{ toJson(inputs.content_raw) }};
            const inMsg   = ( ${{ toJson(inputs.commit_message) }} || "" ).trim();
            const inBase  = ( ${{ toJson(inputs.base_branch) }}    || "" ).trim();

            // Basic guards (fail early)
            if (!inPath) { core.setFailed("file_path is empty"); return; }
            if (!inRaw)  { core.setFailed("content_raw is empty"); return; }
            if (!inMsg)  { core.setFailed("commit_message is empty"); return; }

            // ---- Sanitise and normalise path --------------------------------
            const filePath = inPath
              .replace(/^file_path:\s*/i, "")
              .replace(/\/+/g, "/")
              .replace(/^\/|\/$/g, "");

            const { owner, repo } = context.repo;

            // ---- Resolve base branch (use repository default if blank) -------
            let baseBranch = inBase;
            if (!baseBranch) {
              const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
              baseBranch = repoInfo.default_branch || "main";
            }
            core.info(`Base branch: ${baseBranch}`);

            // ---- Ensure integration branch 'elis-bot' exists -----------------
            const integBranch = "elis-bot";
            try {
              await github.rest.git.getRef({ owner, repo, ref: `heads/${integBranch}` });
              core.info(`Using existing branch '${integBranch}'.`);
            } catch (e) {
              if (e.status !== 404) throw e; // unexpected error
              const { data: baseRef } = await github.rest.git.getRef({
                owner, repo, ref: `heads/${baseBranch}`
              });
              await github.rest.git.createRef({
                owner, repo, ref: `refs/heads/${integBranch}`, sha: baseRef.object.sha
              });
              core.info(`Created branch '${integBranch}' from '${baseBranch}'.`);
            }

            // ---- Create or update the target file on 'elis-bot' --------------
            let currentSha;
            try {
              const { data: existing } = await github.rest.repos.getContent({
                owner, repo, path: filePath, ref: integBranch
              });
              if (!Array.isArray(existing)) currentSha = existing.sha; // update case
            } catch (e) {
              if (e.status !== 404) throw e; // ignore Not Found (new file)
            }

            await github.rest.repos.createOrUpdateFileContents({
              owner, repo, path: filePath, branch: integBranch,
              message: inMsg,
              content: Buffer.from(inRaw, "utf8").toString("base64"),
              sha: currentSha,
              committer: { name: "ELIS Bot", email: "233278419+elis-bot@users.noreply.github.com" },
              author:    { name: "ELIS Bot", email: "233278419+elis-bot@users.noreply.github.com" }
            });

            core.notice(`Committed to '${integBranch}': ${filePath}`);
