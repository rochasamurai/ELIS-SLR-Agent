name: ELIS - Agent Run
# =============================================================================
# Purpose
#   Read Appendix A and generate B/C artefacts. Commit them on a dedicated
#   branch and open/refresh a PR into `main`. Also upload B/C as a run artifact.
#
# Why this change
#   1) Guarantee Appendix C canonical filename is used EXACTLY:
#        json_jsonl/ELIS_Appendix_C_DataExtraction_rows.json
#      We only *verify* (no renames, no shims). If any C-variant exists or the
#      canonical file is missing, the job fails fast with a clear error.
#   2) Fix previous path typos where C file was referred to as "..._Extraction_..."
#      instead of "..._DataExtraction_...".
#
# Usage
#   - Trigger manually (workflow_dispatch).
#   - Inputs:
#       base_branch:   target base to PR into (default: main)
#       write_branch:  desired work branch name (default: ci/agent-autopr)
#       open_pr:       open/refresh a PR when there is a diff (default: true)
# =============================================================================

on:
  workflow_dispatch:
    inputs:
      base_branch:
        description: "Base branch to PR into"
        required: false
        default: "main"
      write_branch:
        description: "Work branch to write artefacts (auto-suffixed if exists)"
        required: false
        default: "ci/agent-autopr"
      open_pr:
        description: "Open/refresh PR write_branch → base_branch"
        required: false
        default: "true"

# We need write perms to push and open PRs.
permissions:
  contents: write
  pull-requests: write

concurrency:
  group: agent-run-${{ github.ref }}
  cancel-in-progress: false

jobs:
  run-agent:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      # 1) Mint a GitHub App token. This identity owns the push & PR.
      - name: Mint installation token (GitHub App)
        id: app
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.ELIS_APP_ID }}
          private-key: ${{ secrets.ELIS_APP_PRIVATE_KEY }}

      # 2) Checkout USING the App token so the remote is credentialed.
      - name: Checkout repository (App token)
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app.outputs.token }}
          fetch-depth: 0

      # 3) Git identity for commits.
      - name: Configure Git identity
        run: |
          git config user.name  "elis-bot"
          git config user.email "elis-bot@users.noreply.github.com"

      # 4) Resolve base/head branch names (with sensible defaults).
      - name: Resolve branches
        id: br
        run: |
          BASE="${{ github.event.inputs.base_branch || 'main' }}"
          HEAD="${{ github.event.inputs.write_branch || 'ci/agent-autopr' }}"
          echo "base=$BASE" >> "$GITHUB_OUTPUT"
          echo "head=$HEAD" >> "$GITHUB_OUTPUT"

      # 5) Prepare the write branch BEFORE running the agent.
      - name: Prepare write branch (create or fast-forward)
        run: |
          set -eux
          BASE="${{ steps.br.outputs.base }}"
          HEAD="${{ steps.br.outputs.head }}"
          git fetch origin --prune
          if git ls-remote --exit-code --heads origin "$HEAD" >/dev/null 2>&1; then
            git checkout -B "$HEAD" "origin/$HEAD"
            # Bring it up to date with base if fast-forwardable.
            (git merge --ff-only "origin/$BASE" && echo "FF merged base") || true
          else
            git checkout -B "$HEAD" "origin/$BASE"
            git push -u origin "$HEAD"
          fi

      # 6) Python + deps
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # 6.1) PRE-RUN GUARD — Verify canonical Appendix C filename exists and no variants.
      #      This is a *verification only* step (no renames, no shims).
      - name: Verify canonical Appendix C filename (pre-run)
        shell: bash
        run: |
          set -euo pipefail
          CANONICAL="json_jsonl/ELIS_Appendix_C_DataExtraction_rows.json"

          # Must exist at the exact path
          if [[ ! -f "$CANONICAL" ]]; then
            echo "::error::Missing canonical file at $CANONICAL. Ensure the agent writes here."
            exit 2
          fi

          # No confusing C-variants (case-insensitive) alongside the canonical file
          mapfile -t VARIANTS < <(find json_jsonl -maxdepth 1 -type f \
            -iregex '.*/ELIS[ _-]*Appendix[ _-]*C[ _-]*.*rows\.\(json\|jsonl\)$' \
            ! -path "$CANONICAL")
          if (( ${#VARIANTS[@]} > 0 )); then
            printf '%s\n' "${VARIANTS[@]}" | sed 's/^/::error::Found non-canonical C variant: /'
            exit 3
          fi

          # Optional content sanity check if jq is available (skip silently if not)
          if command -v jq >/dev/null 2>&1; then
            jq -e 'type=="array"' "$CANONICAL" >/dev/null || (echo "::error::C file must be a JSON array"; exit 5)
          fi

          echo "✅ Canonical C path verified (pre-run)."

      # 7) Run the agent (writes ONLY B/C from Appendix A).
      - name: Run Toy Agent (B/C only)
        run: |
          set -eux
          python scripts/agent.py --write-bc-only

      # 7.1) POST-RUN GUARD — Ensure the agent did not deviate from the canonical C name.
      - name: Verify canonical Appendix C filename (post-run)
        shell: bash
        run: |
          set -euo pipefail
          CANONICAL="json_jsonl/ELIS_Appendix_C_DataExtraction_rows.json"
          [[ -f "$CANONICAL" ]] || { echo "::error::Agent did not produce $CANONICAL"; exit 6; }
          echo "✅ Canonical C path verified (post-run)."

      # 8) Upload artefacts for download/debug.
      - name: Upload artefacts (B/C)
        uses: actions/upload-artifact@v4
        with:
          name: elis-agent-artefacts
          path: |
            json_jsonl/ELIS_Appendix_B_Screening_rows.json
            json_jsonl/ELIS_Appendix_C_DataExtraction_rows.json

      # 9) Stage & commit ONLY when B/C changed.
      - name: Commit artefacts (B/C only when changed)
        run: |
          set -eux
          git add -N \
            json_jsonl/ELIS_Appendix_B_Screening_rows.json \
            json_jsonl/ELIS_Appendix_C_DataExtraction_rows.json || true

          if git diff --name-only --exit-code -- \
              json_jsonl/ELIS_Appendix_B_Screening_rows.json \
              json_jsonl/ELIS_Appendix_C_DataExtraction_rows.json; then
            echo "No artefact diffs; skipping commit/push/PR."
            echo "skip_pr=true" >> "$GITHUB_ENV"
            exit 0
          fi

          git add \
            json_jsonl/ELIS_Appendix_B_Screening_rows.json \
            json_jsonl/ELIS_Appendix_C_DataExtraction_rows.json

          git commit -m "feat(agent): add B/C artefacts from Appendix A"

      # 10) Overwrite 'origin' to the App-token URL (permanent push fix).
      - name: Force remote to App-token URL (fix push auth)
        if: env.skip_pr != 'true'
        run: |
          set -eux
          git remote set-url origin "https://x-access-token:${{ steps.app.outputs.token }}@github.com/${{ github.repository }}"

      # 11) Push work branch.
      - name: Push work branch
        if: env.skip_pr != 'true'
        run: |
          set -eux
          HEAD="${{ steps.br.outputs.head }}"
          git push --force-with-lease origin HEAD:"$HEAD"

      # 12) Compare base..head and open PR using the App token.
      - name: Compare base..head & open/refresh PR
        if: ${{ env.skip_pr != 'true' && fromJSON(github.event.inputs.open_pr || 'true') }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ steps.app.outputs.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const base  = "${{ steps.br.outputs.base }}";
            const head  = "${{ steps.br.outputs.head }}";

            const cmp = await github.rest.repos.compareCommitsWithBasehead({
              owner, repo, basehead: `${base}...${head}`,
            });

            const hasDiff = (cmp.data.ahead_by > 0) || ((cmp.data.files || []).length > 0);
            if (!hasDiff) { core.info("No diff; no PR opened."); return; }

            const { data: openPRs } = await github.rest.pulls.list({
              owner, repo, state: 'open', base, head: `${owner}:${head}`,
            });

            if (openPRs.length > 0) {
              core.info(`PR already open: #${openPRs[0].number}`);
            } else {
              const { data: pr } = await github.rest.pulls.create({
                owner, repo, base, head,
                title: "feat(agent): add B/C artefacts from Appendix A",
                body: "Automated agent run using ELIS – Agent Run.",
              });
              core.info(`Opened PR #${pr.number}`);
            }
