name: ELIS - Agent Run
# =============================================================================
# Purpose
#   Read Appendix A and generate B/C artefacts. Commit them on a dedicated
#   branch and open/refresh a PR into `main`. Also upload B/C as a run artifact.
#
# Why this change
#   Fixes "local changes would be overwritten by checkout" by preparing the
#   write branch BEFORE running the agent. We then write files, commit, push,
#   and only then open a PR (guarded by a base..head diff).
#
# Usage
#   - Trigger manually (workflow_dispatch).
#   - Inputs:
#       base_branch:   target base to PR into (default: main)
#       write_branch:  desired work branch name (default: ci/agent-autopr)
#       open_pr:       open/refresh a PR when there is a diff (default: true)
# =============================================================================

on:
  workflow_dispatch:
    inputs:
      base_branch:
        description: "Base branch to PR into"
        required: false
        default: "main"
      write_branch:
        description: "Preferred work branch (auto-suffixed if already exists)"
        required: false
        default: "ci/agent-autopr"
      open_pr:
        description: "Open/refresh PR write_branch â†’ base_branch"
        required: false
        default: "true"

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: agent-run-${{ github.event.inputs.write_branch || 'ci/agent-autopr' }}
  cancel-in-progress: false

jobs:
  agent-run:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    env:
      BASE_BRANCH:  ${{ github.event.inputs.base_branch }}
      WRITE_WANT:   ${{ github.event.inputs.write_branch }}
      OPEN_PR:      ${{ github.event.inputs.open_pr }}

    steps:
      # 1) Checkout base branch (clean slate)
      - name: Checkout base
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH || 'main' }}
          fetch-depth: 0

      # 2) Git identity
      - name: Configure Git identity
        run: |
          set -eux
          git config user.name  "elis-bot"
          git config user.email "elis-bot@users.noreply.github.com"
          # Ensure LF endings to avoid cross-OS churn
          git config core.autocrlf false
          git config core.eol lf

      # 3) Prepare a fresh work branch BEFORE running the agent
      #    - If requested branch exists on origin, suffix with UTC timestamp.
      #    - Always start from origin/BASE.
      - name: Prepare work branch
        id: prep
        run: |
          set -eux
          BASE="${BASE_BRANCH:-main}"
          WANT="${WRITE_WANT:-ci/agent-autopr}"

          git fetch origin --prune

          if git ls-remote --exit-code --heads origin "$WANT" >/dev/null 2>&1; then
            TS="$(date -u +%Y%m%d-%H%M%S)"
            HEAD_BRANCH="${WANT}-${TS}"
          else
            HEAD_BRANCH="$WANT"
          fi

          git checkout -B "$HEAD_BRANCH" "origin/$BASE"

          echo "HEAD_BRANCH=$HEAD_BRANCH" >> "$GITHUB_ENV"
          echo "head_branch=$HEAD_BRANCH"  >> "$GITHUB_OUTPUT"

      # 4) Set up Python (agent uses stdlib; no extra deps needed)
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # 5) Run the agent (reads A; writes only B & C as agreed)
      - name: Run agent
        run: |
          set -eux
          python --version
          python scripts/agent.py

      # 6) Stage only B/C artefacts, detect no-op runs early
      - name: Stage & detect changes
        id: diff
        run: |
          set -eux
          B="json_jsonl/ELIS_Appendix_B_Screening_rows.json"
          C="json_jsonl/ELIS_Appendix_C_Extraction_rows.json"

          # Intend-to-add so diff works if files are new
          git add -N "$B" "$C" || true

          # If neither file changed, short-circuit the job
          if git diff --name-only --exit-code -- "$B" "$C" >/dev/null; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            echo "No B/C changes detected; nothing to commit."
          else
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
          fi

      # 7) Commit & push if there are changes
      - name: Commit & push
        if: steps.diff.outputs.has_changes == 'true'
        run: |
          set -eux
          B="json_jsonl/ELIS_Appendix_B_Screening_rows.json"
          C="json_jsonl/ELIS_Appendix_C_Extraction_rows.json"

          git add "$B" "$C"
          git commit -m "feat(agent): add B/C artefacts from Appendix A"
          # Push safely to the prepared head branch
          git push --force-with-lease origin HEAD:"$HEAD_BRANCH"
          echo "Pushed $(git rev-parse --short HEAD) to $HEAD_BRANCH"

      # 8) Upload the two files as run artifacts (downloadable from the run page)
      - name: Upload artefacts (B/C)
        uses: actions/upload-artifact@v4
        with:
          name: elis-agent-artefacts
          path: |
            json_jsonl/ELIS_Appendix_B_Screening_rows.json
            json_jsonl/ELIS_Appendix_C_Extraction_rows.json
          if-no-files-found: warn
          retention-days: 7

      # 9) Compare base..head; only open PR if there is a diff (guards API 422)
      - name: Compare base..head
        id: cmp
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const base  = process.env.BASE_BRANCH || 'main';
            const head  = process.env.HEAD_BRANCH; // set in Prepare work branch

            if (!head) {
              core.setOutput('has_diff', 'false');
              core.info('No head branch resolved; skipping PR compare.');
              return;
            }

            const cmp = await github.rest.repos.compareCommitsWithBasehead({
              owner, repo, basehead: `${base}...${head}`,
            });

            const hasDiff = (cmp.data.ahead_by > 0) || ((cmp.data.files || []).length > 0);
            core.setOutput('has_diff', hasDiff ? 'true' : 'false');
            core.info(`Diff? ${hasDiff} (ahead_by=${cmp.data.ahead_by}, behind_by=${cmp.data.behind_by})`);

      # 10) Open/refresh PR (only when requested and there is a diff)
      - name: Open/refresh PR to base
        if: ${{ env.OPEN_PR == 'true' && steps.cmp.outputs.has_diff == 'true' }}
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const base  = process.env.BASE_BRANCH || 'main';
            const head  = process.env.HEAD_BRANCH;

            // If a PR already exists, do nothing.
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: 'open', base, head: `${owner}:${head}`,
            });

            if (prs.length > 0) {
              core.info(`PR already open: #${prs[0].number}`);
              return;
            }

            const title = "feat(agent): add B/C artefacts from Appendix A";
            const body  = [
              "Automated agent run:",
              "- Reads Appendix A input",
              "- Writes Appendix B/C artefacts",
              "- Validated via CI on PR",
              "",
              "_This PR was opened by **ELIS - Agent Run**._",
            ].join("\n");

            const { data: pr } = await github.rest.pulls.create({
              owner, repo, base, head, title, body,
            });
            core.info(`Opened PR #${pr.number}`);

      # 11) Finish cleanly when there is nothing to commit/PR
      - name: No-op note
        if: ${{ steps.diff.outputs.has_changes != 'true' }}
        run: echo "Agent produced no changes this time (files identical)."
