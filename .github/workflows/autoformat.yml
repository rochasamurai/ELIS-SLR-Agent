name: ELIS - Autoformat
# ============================================================================
# Purpose
#   Run Black on a target branch (default: `elis-bot`). If changes occur,
#   commit and push them, then (optionally) open/refresh a PR into `main`.
#
# Key fixes in this version
#   • Robust sync: handle unrelated histories and dirty trees safely.
#   • Normalise line endings per `.gitattributes` to avoid Black "would reformat".
#   • Always push the bot branch correctly (uses --force-with-lease when reset).
#   • Correct PR step: pass workflow inputs via env to actions/github-script.
#
# Usage
#   Actions → "ELIS - Autoformat" → Run workflow
#     - base_branch   (default: main)
#     - target_branch (default: elis-bot)
#     - open_pr       (default: true)
# ============================================================================

on:
  workflow_dispatch:
    inputs:
      base_branch:
        description: "Base branch to PR into"
        required: false
        default: "main"
      target_branch:
        description: "Branch to autoformat (in-place)"
        required: false
        default: "elis-bot"
      open_pr:
        description: "Open/refresh PR target_branch → base_branch"
        required: false
        default: "true"

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: autoformat-${{ inputs.target_branch }}
  cancel-in-progress: false

jobs:
  autoformat:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      # 1) Mint a short-lived GitHub App installation token
      - name: Mint installation token (GitHub App)
        id: app
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.ELIS_APP_ID }}
          private-key: ${{ secrets.ELIS_APP_PRIVATE_KEY }}

      # 2) Checkout the repository (we will position to target branch next)
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Use the token from the GitHub App so we can push
          token: ${{ steps.app.outputs.token }}
          fetch-depth: 0

      # 3) Configure Git identity (needed for rebase/commit)
      - name: Configure Git identity
        run: |
          git config user.name  "elis-bot"
          git config user.email "elis-bot@users.noreply.github.com"

      # 4) Ensure we are on the target branch and that it tracks remote.
      #    - If the remote branch does not exist, create it from base.
      - name: Prepare target branch
        env:
          BASE:  ${{ inputs.base_branch }}
          HEAD:  ${{ inputs.target_branch }}
        run: |
          set -eux
          git fetch origin --prune
          # Clean any local changes before branch operations
          git reset --hard
          git clean -fdx

          if git ls-remote --exit-code --heads origin "$HEAD" >/dev/null 2>&1; then
            # Branch exists on remote: track it locally
            git checkout -B "$HEAD" "origin/$HEAD"
          else
            # Branch does not exist: create it from base
            git checkout -B "$HEAD" "origin/$BASE"
            # Push initial branch so subsequent steps can push updates
            git push -u origin "$HEAD"
          fi

      # 5) Sync target from base robustly:
      #    - Try rebase onto base.
      #    - If rebase fails (unrelated histories or conflicts), abort and
      #      hard-reset target to base. This is safe for a bot branch.
      - name: Sync target from base (rebase or reset)
        env:
          BASE:  ${{ inputs.base_branch }}
          HEAD:  ${{ inputs.target_branch }}
        run: |
          set -eux
          git fetch origin "$BASE" --depth=1
          # Rebase; if it fails, reset to base (safe for automation branch)
          if ! git rebase "origin/$BASE"; then
            git rebase --abort || true
            echo "Rebase failed or histories unrelated; resetting $HEAD to origin/$BASE"
            git reset --hard "origin/$BASE"
          fi

      # 6) Normalise line endings per .gitattributes (prevents 'would reformat')
      - name: Normalise line endings (.gitattributes)
        run: |
          set -eux
          git add --renormalize .
          if ! git diff --cached --quiet; then
            git commit -m "chore(format): normalise line endings per .gitattributes"
          else
            echo "No line-ending normalisation needed."
          fi

      # 7) Set up Python and install Black (pinned)
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Black
        run: |
          python -m pip install --upgrade pip
          pip install black==24.8.0

      # 8) Run Black in-place
      - name: Run Black (format in-place)
        run: black .

      # 9) Commit & push any changes. Use --force-with-lease to cover the
      #    reset case above while protecting against concurrent updates.
      - name: Commit and push formatting changes
        env:
          HEAD:  ${{ inputs.target_branch }}
        run: |
          set -eux
          if ! git diff --quiet; then
            git add -A
            git commit -m "chore(format): apply Black autoformat"
          fi
          # Push if ahead; allow non-FF if we reset-to-base earlier
          AHEAD=$(git rev-list --left-only --count "origin/$HEAD..HEAD" || echo 0)
          if [ "$AHEAD" -gt 0 ]; then
            git push --force-with-lease origin HEAD:"$HEAD"
            echo "Pushed: $(git rev-parse --short HEAD)"
          else
            echo "No changes to push."
          fi

      # 10) Open or refresh PR target→base (idempotent; reads inputs via env)
      - name: Open/refresh PR to base
        if: ${{ inputs.open_pr == 'true' }}
        uses: actions/github-script@v6
        env:
          BASE_BRANCH: ${{ inputs.base_branch }}
          HEAD_BRANCH: ${{ inputs.target_branch }}
        with:
          github-token: ${{ steps.app.outputs.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const base  = process.env.BASE_BRANCH || 'main';
            const head  = process.env.HEAD_BRANCH || 'elis-bot';

            const { data: prs } = await github.pulls.list({
              owner, repo, state: 'open', base, head: `${owner}:${head}`,
            });

            if (prs.length === 0) {
              const { data: pr } = await github.pulls.create({
                owner, repo, base, head,
                title: "chore(format): apply Black autoformat",
                body: "Automated formatting and line-ending normalisation by ELIS - Autoformat.",
              });
              core.info(`Opened PR #${pr.number}`);
            } else {
              core.info(`PR already open: #${prs[0].number}`);
            }
