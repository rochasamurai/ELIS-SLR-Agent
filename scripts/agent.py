#!/usr/bin/env python3 """ ELIS SLR Agent — Toy Run (A → B → C)  Purpose ------- Minimal, deterministic* agent stub that writes one example record into each runtime artefact (Appendix A/B/C) under `json_jsonl/`. This is the smallest end-to-end slice to exercise the repository wiring (CI, validation, workflows).  (*) Determinism: by default the script uses the current UTC time for `created_at`. If you need full determinism across runs, set the environment variable `ELIS_FIXED_ISO` to an ISO 8601 timestamp (e.g. "2025-01-01T00:00:00Z"); the script will then use that exact value on every execution.  Outputs ------- - json_jsonl/ELIS_Appendix_A_Search_rows.json - json_jsonl/ELIS_Appendix_B_Screening_rows.json - json_jsonl/ELIS_Appendix_C_DataExtraction_rows.json  Each file is a JSON array with a single object containing the minimal common fields required by our toy scenario:     - id          : stable identifier string for the record     - source      : human-readable provenance     - created_at  : ISO 8601 UTC timestamp (string, ends with 'Z')     - note        : short explanatory note (UK English)  Conventions ----------- - UK English for comments and messages. - Idempotent writes: the files are **fully overwritten** on each run so that   subsequent validations operate on a known, clean state. - Safe I/O: create directories if missing; write atomically via temp file + rename.  Usage ----- python scripts/agent.py """  from __future__ import annotations  import json import os from datetime import datetime, timezone from pathlib import Path from typing import Any, Dict, List, Tuple   # ---------- Repository layout (relative to this file) ---------- ROOT = Path(__file__).resolve().parents[1] DATA_DIR = ROOT / "json_jsonl"  A_PATH = DATA_DIR / "ELIS_Appendix_A_Search_rows.json" B_PATH = DATA_DIR / "ELIS_Appendix_B_Screening_rows.json" C_PATH = DATA_DIR / "ELIS_Appendix_C_DataExtraction_rows.json"   # ---------- Time helpers ---------- def utc_now_isoz() -> str:     """Return current UTC time in ISO 8601 with 'Z' suffix."""     return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")   def resolved_created_at() -> str:     """     Resolve the timestamp to write into records.      Priority:     1) Environment variable ELIS_FIXED_ISO (must be a valid ISO 8601 string).     2) Current UTC time.     """     fixed = os.getenv("ELIS_FIXED_ISO", "").strip()     if fixed:         # Basic sanity: accept only forms ending with 'Z' to denote UTC.         # If malformed, we still fall back to 'now' to avoid crashing the run.         try:             # Attempt to parse a few common ISO shapes. If it fails, raise.             datetime.strptime(fixed, "%Y-%m-%dT%H:%M:%SZ")             return fixed         except Exception:             pass     return utc_now_isoz()   # ---------- I/O utilities ---------- def atomic_write_json_array(path: Path, rows: List[Dict[str, Any]]) -> None:     """     Safely write a JSON array to `path`:     - Ensures parent directory exists.     - Writes to a temporary file first, then renames (best-effort atomicity).     - Uses UTF-8 and pretty indentation for human review.     """     path.parent.mkdir(parents=True, exist_ok=True)     tmp = path.with_suffix(path.suffix + ".tmp")     with tmp.open("w", encoding="utf-8") as fh:         json.dump(rows, fh, ensure_ascii=False, indent=2)         fh.write("\n")  # trailing newline helps POSIX tools and clean diffs     tmp.replace(path)   # ---------- Toy record generators ---------- def make_a_rows(created_at: str) -> List[Dict[str, Any]]:     """     Make one minimal Search (Appendix A) record.      Fields here are illustrative; real fields will follow the schema once the     full agent is wired to the ELIS Data Contract.     """     return [         {             "id": "A-0001",             "source": "toy:agent",             "created_at": created_at,             "note": "Toy Search row generated by ELIS Agent stub.",         }     ]   def make_b_rows(created_at: str) -> List[Dict[str, Any]]:     """Make one minimal Screening (Appendix B) record."""     return [         {             "id": "B-0001",             "source": "toy:agent",             "created_at": created_at,             "note": "Toy Screening row generated by ELIS Agent stub.",         }     ]   def make_c_rows(created_at: str) -> List[Dict[str, Any]]:     """Make one minimal Data Extraction (Appendix C) record."""     return [         {             "id": "C-0001",             "source": "toy:agent",             "created_at": created_at,             "note": "Toy Data Extraction row generated by ELIS Agent stub.",         }     ]   # ---------- Main entry point ---------- def run_toy() -> Tuple[Path, Path, Path]:     """     Generate and write the three toy artefacts.     Returns the three output paths for logging or testing convenience.     """     created_at = resolved_created_at()      a_rows = make_a_rows(created_at)     b_rows = make_b_rows(created_at)     c_rows = make_c_rows(created_at)      atomic_write_json_array(A_PATH, a_rows)     atomic_write_json_array(B_PATH, b_rows)     atomic_write_json_array(C_PATH, c_rows)      return A_PATH, B_PATH, C_PATH   def main() -> int:     """     Execute the toy run and print a concise, review-friendly summary.     Exit code 0 indicates success; any exception will bubble up (CI will fail).     """     a, b, c = run_toy()     print("ELIS Agent (Toy Run) wrote:")     print(f"- {a.relative_to(ROOT)}")     print(f"- {b.relative_to(ROOT)}")     print(f"- {c.relative_to(ROOT)}")     return 0   if __name__ == "__main__":     raise SystemExit(main())